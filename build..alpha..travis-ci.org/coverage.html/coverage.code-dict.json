{"/home/travis/build/npmtest/node-npmtest-ref/test.js":"/* istanbul instrument in package npmtest_ref */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ref/lib.npmtest_ref.js":"/* istanbul instrument in package npmtest_ref */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ref = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ref = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ref/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ref && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ref */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ref\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ref.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ref.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ref.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ref.__dirname + '/lib.npmtest_ref.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ref/node_modules/ref/lib/ref.js":"\nvar assert = require('assert')\nvar debug = require('debug')('ref')\n\nexports = module.exports = require('bindings')('binding')\n\n/**\n * A `Buffer` that references the C NULL pointer. That is, its memory address\n * points to 0. Its `length` is 0 because accessing any data from this buffer\n * would cause a _segmentation fault_.\n *\n * ```\n * console.log(ref.NULL);\n * <SlowBuffer@0x0 >\n * ```\n *\n * @name NULL\n * @type Buffer\n */\n\n/**\n * A string that represents the native endianness of the machine's processor.\n * The possible values are either `\"LE\"` or `\"BE\"`.\n *\n * ```\n * console.log(ref.endianness);\n * 'LE'\n * ```\n *\n * @name endianness\n * @type String\n */\n\n/**\n * Accepts a `Buffer` instance and returns the memory address of the buffer\n * instance.\n *\n * ```\n * console.log(ref.address(new Buffer(1)));\n * 4320233616\n *\n * console.log(ref.address(ref.NULL)));\n * 0\n * ```\n *\n * @param {Buffer} buffer The buffer to get the memory address of.\n * @return {Number} The memory address the buffer instance.\n * @name address\n * @type method\n */\n\n/**\n * Accepts a `Buffer` instance and returns _true_ if the buffer represents the\n * NULL pointer, _false_ otherwise.\n *\n * ```\n * console.log(ref.isNull(new Buffer(1)));\n * false\n *\n * console.log(ref.isNull(ref.NULL));\n * true\n * ```\n *\n * @param {Buffer} buffer The buffer to check for NULL.\n * @return {Boolean} true or false.\n * @name isNull\n * @type method\n */\n\n/**\n * Reads a JavaScript Object that has previously been written to the given\n * _buffer_ at the given _offset_.\n *\n * ```\n * var obj = { foo: 'bar' };\n * var buf = ref.alloc('Object', obj);\n *\n * var obj2 = ref.readObject(buf, 0);\n * console.log(obj === obj2);\n * true\n * ```\n *\n * @param {Buffer} buffer The buffer to read an Object from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Object} The Object that was read from _buffer_.\n * @name readObject\n * @type method\n */\n\n/**\n * Reads a Buffer instance from the given _buffer_ at the given _offset_.\n * The _size_ parameter specifies the `length` of the returned Buffer instance,\n * which defaults to __0__.\n *\n * ```\n * var buf = new Buffer('hello world');\n * var pointer = ref.alloc('pointer');\n *\n * var buf2 = ref.readPointer(pointer, 0, buf.length);\n * console.log(buf.toString());\n * 'hello world'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @param {Number} length (optional) The length of the returned Buffer. Defaults to 0.\n * @return {Buffer} The Buffer instance that was read from _buffer_.\n * @name readPointer\n * @type method\n */\n\n/**\n * Returns a JavaScript String read from _buffer_ at the given _offset_. The\n * C String is read until the first NULL byte, which indicates the end of the\n * String.\n *\n * This function can read beyond the `length` of a Buffer.\n *\n * ```\n * var buf = new Buffer('hello\\0world\\0');\n *\n * var str = ref.readCString(buf, 0);\n * console.log(str);\n * 'hello'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {String} The String that was read from _buffer_.\n * @name readCString\n * @type method\n */\n\n/**\n * Returns a big-endian signed 64-bit int read from _buffer_ at the given\n * _offset_.\n *\n * If the returned value will fit inside a JavaScript Number without losing\n * precision, then a Number is returned, otherwise a String is returned.\n *\n * ```\n * var buf = ref.alloc('int64');\n * ref.writeInt64BE(buf, 0, '9223372036854775807');\n *\n * var val = ref.readInt64BE(buf, 0)\n * console.log(val)\n * '9223372036854775807'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Number|String} The Number or String that was read from _buffer_.\n * @name readInt64BE\n * @type method\n */\n\n/**\n * Returns a little-endian signed 64-bit int read from _buffer_ at the given\n * _offset_.\n *\n * If the returned value will fit inside a JavaScript Number without losing\n * precision, then a Number is returned, otherwise a String is returned.\n *\n * ```\n * var buf = ref.alloc('int64');\n * ref.writeInt64LE(buf, 0, '9223372036854775807');\n *\n * var val = ref.readInt64LE(buf, 0)\n * console.log(val)\n * '9223372036854775807'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Number|String} The Number or String that was read from _buffer_.\n * @name readInt64LE\n * @type method\n */\n\n/**\n * Returns a big-endian unsigned 64-bit int read from _buffer_ at the given\n * _offset_.\n *\n * If the returned value will fit inside a JavaScript Number without losing\n * precision, then a Number is returned, otherwise a String is returned.\n *\n * ```\n * var buf = ref.alloc('uint64');\n * ref.writeUInt64BE(buf, 0, '18446744073709551615');\n *\n * var val = ref.readUInt64BE(buf, 0)\n * console.log(val)\n * '18446744073709551615'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Number|String} The Number or String that was read from _buffer_.\n * @name readUInt64BE\n * @type method\n */\n\n/**\n * Returns a little-endian unsigned 64-bit int read from _buffer_ at the given\n * _offset_.\n *\n * If the returned value will fit inside a JavaScript Number without losing\n * precision, then a Number is returned, otherwise a String is returned.\n *\n * ```\n * var buf = ref.alloc('uint64');\n * ref.writeUInt64LE(buf, 0, '18446744073709551615');\n *\n * var val = ref.readUInt64LE(buf, 0)\n * console.log(val)\n * '18446744073709551615'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Number|String} The Number or String that was read from _buffer_.\n * @name readUInt64LE\n * @type method\n */\n\n/**\n * Writes the _input_ Number or String as a big-endian signed 64-bit int into\n * _buffer_ at the given _offset_.\n *\n * ```\n * var buf = ref.alloc('int64');\n * ref.writeInt64BE(buf, 0, '9223372036854775807');\n * ```\n *\n * @param {Buffer} buffer The buffer to write to.\n * @param {Number} offset The offset to begin writing from.\n * @param {Number|String} input This String or Number which gets written.\n * @name writeInt64BE\n * @type method\n */\n\n/**\n * Writes the _input_ Number or String as a little-endian signed 64-bit int into\n * _buffer_ at the given _offset_.\n *\n * ```\n * var buf = ref.alloc('int64');\n * ref.writeInt64LE(buf, 0, '9223372036854775807');\n * ```\n *\n * @param {Buffer} buffer The buffer to write to.\n * @param {Number} offset The offset to begin writing from.\n * @param {Number|String} input This String or Number which gets written.\n * @name writeInt64LE\n * @type method\n */\n\n/**\n * Writes the _input_ Number or String as a big-endian unsigned 64-bit int into\n * _buffer_ at the given _offset_.\n *\n * ```\n * var buf = ref.alloc('uint64');\n * ref.writeUInt64BE(buf, 0, '18446744073709551615');\n * ```\n *\n * @param {Buffer} buffer The buffer to write to.\n * @param {Number} offset The offset to begin writing from.\n * @param {Number|String} input This String or Number which gets written.\n * @name writeUInt64BE\n * @type method\n */\n\n/**\n * Writes the _input_ Number or String as a little-endian unsigned 64-bit int\n * into _buffer_ at the given _offset_.\n *\n * ```\n * var buf = ref.alloc('uint64');\n * ref.writeUInt64LE(buf, 0, '18446744073709551615');\n * ```\n *\n * @param {Buffer} buffer The buffer to write to.\n * @param {Number} offset The offset to begin writing from.\n * @param {Number|String} input This String or Number which gets written.\n * @name writeUInt64LE\n * @type method\n */\n\n/**\n * Returns a new clone of the given \"type\" object, with its\n * `indirection` level incremented by **1**.\n *\n * Say you wanted to create a type representing a `void *`:\n *\n * ```\n * var voidPtrType = ref.refType(ref.types.void);\n * ```\n *\n * @param {Object|String} type The \"type\" object to create a reference type from. Strings get coerced first.\n * @return {Object} The new \"type\" object with its `indirection` incremented by 1.\n */\n\nexports.refType = function refType (type) {\n  var _type = exports.coerceType(type)\n  var rtn = Object.create(_type)\n  rtn.indirection++\n  if (_type.name) {\n    Object.defineProperty(rtn, 'name', {\n      value: _type.name + '*',\n      configurable: true,\n      enumerable: true,\n      writable: true\n    })\n  }\n  return rtn\n}\n\n/**\n * Returns a new clone of the given \"type\" object, with its\n * `indirection` level decremented by 1.\n *\n * @param {Object|String} type The \"type\" object to create a dereference type from. Strings get coerced first.\n * @return {Object} The new \"type\" object with its `indirection` decremented by 1.\n */\n\nexports.derefType = function derefType (type) {\n  var _type = exports.coerceType(type)\n  if (_type.indirection === 1) {\n    throw new Error('Cannot create deref\\'d type for type with indirection 1')\n  }\n  var rtn = Object.getPrototypeOf(_type)\n  if (rtn.indirection !== _type.indirection - 1) {\n    // slow case\n    rtn = Object.create(_type)\n    rtn.indirection--\n  }\n  return rtn\n}\n\n/**\n * Coerces a \"type\" object from a String or an actual \"type\" object. String values\n * are looked up from the `ref.types` Object. So:\n *\n *   * `\"int\"` gets coerced into `ref.types.int`.\n *   * `\"int *\"` gets translated into `ref.refType(ref.types.int)`\n *   * `ref.types.int` gets translated into `ref.types.int` (returns itself)\n *\n * Throws an Error if no valid \"type\" object could be determined. Most `ref`\n * functions use this function under the hood, so anywhere a \"type\" object is\n * expected, a String may be passed as well, including simply setting the\n * `buffer.type` property.\n *\n * ```\n * var type = ref.coerceType('int **');\n *\n * console.log(type.indirection);\n * 3\n * ```\n *\n * @param {Object|String} type The \"type\" Object or String to coerce.\n * @return {Object} A \"type\" object\n */\n\nexports.coerceType = function coerceType (type) {\n  var rtn = type\n  if (typeof rtn === 'string') {\n    rtn = exports.types[type]\n    if (rtn) return rtn\n\n    // strip whitespace\n    rtn = type.replace(/\\s+/g, '').toLowerCase()\n    if (rtn === 'pointer') {\n      // legacy \"pointer\" being used :(\n      rtn = exports.refType(exports.types.void) // void *\n    } else if (rtn === 'string') {\n      rtn = exports.types.CString // special char * type\n    } else {\n      var refCount = 0\n      rtn = rtn.replace(/\\*/g, function () {\n        refCount++\n        return ''\n      })\n      // allow string names to be passed in\n      rtn = exports.types[rtn]\n      if (refCount > 0) {\n        if (!(rtn && 'size' in rtn && 'indirection' in rtn)) {\n          throw new TypeError('could not determine a proper \"type\" from: ' + JSON.stringify(type))\n        }\n        for (var i = 0; i < refCount; i++) {\n          rtn = exports.refType(rtn)\n        }\n      }\n    }\n  }\n  if (!(rtn && 'size' in rtn && 'indirection' in rtn)) {\n    throw new TypeError('could not determine a proper \"type\" from: ' + JSON.stringify(type))\n  }\n  return rtn\n}\n\n/**\n * Returns the \"type\" property of the given Buffer.\n * Creates a default type for the buffer when none exists.\n *\n * @param {Buffer} buffer The Buffer instance to get the \"type\" object from.\n * @return {Object} The \"type\" object from the given Buffer.\n */\n\nexports.getType = function getType (buffer) {\n  if (!buffer.type) {\n    debug('WARN: no \"type\" found on buffer, setting default \"type\"', buffer)\n    buffer.type = {}\n    buffer.type.size = buffer.length\n    buffer.type.indirection = 1\n    buffer.type.get = function get () {\n      throw new Error('unknown \"type\"; cannot get()')\n    }\n    buffer.type.set = function set () {\n      throw new Error('unknown \"type\"; cannot set()')\n    }\n  }\n  return exports.coerceType(buffer.type)\n}\n\n/**\n * Calls the `get()` function of the Buffer's current \"type\" (or the\n * passed in _type_ if present) at the given _offset_.\n *\n * This function handles checking the \"indirection\" level and returning a\n * proper \"dereferenced\" Bufffer instance when necessary.\n *\n * @param {Buffer} buffer The Buffer instance to read from.\n * @param {Number} offset (optional) The offset on the Buffer to start reading from. Defaults to 0.\n * @param {Object|String} type (optional) The \"type\" object to use when reading. Defaults to calling `getType()` on the buffer.\n * @return {?} Whatever value the \"type\" used when reading returns.\n */\n\nexports.get = function get (buffer, offset, type) {\n  if (!offset) {\n    offset = 0\n  }\n  if (type) {\n    type = exports.coerceType(type)\n  } else {\n    type = exports.getType(buffer)\n  }\n  debug('get(): (offset: %d)', offset, buffer)\n  assert(type.indirection > 0, '\"indirection\" level must be at least 1')\n  if (type.indirection === 1) {\n    // need to check \"type\"\n    return type.get(buffer, offset)\n  } else {\n    // need to create a deref'd Buffer\n    var size = type.indirection === 2 ? type.size : exports.sizeof.pointer\n    var reference = exports.readPointer(buffer, offset, size)\n    reference.type = exports.derefType(type)\n    return reference\n  }\n}\n\n/**\n * Calls the `set()` function of the Buffer's current \"type\" (or the\n * passed in _type_ if present) at the given _offset_.\n *\n * This function handles checking the \"indirection\" level writing a pointer rather\n * than calling the `set()` function if the indirection is greater than 1.\n *\n * @param {Buffer} buffer The Buffer instance to write to.\n * @param {Number} offset The offset on the Buffer to start writing to.\n * @param {?} value The value to write to the Buffer instance.\n * @param {Object|String} type (optional) The \"type\" object to use when reading. Defaults to calling `getType()` on the buffer.\n */\n\nexports.set = function set (buffer, offset, value, type) {\n  if (!offset) {\n    offset = 0\n  }\n  if (type) {\n    type = exports.coerceType(type)\n  } else {\n    type = exports.getType(buffer)\n  }\n  debug('set(): (offset: %d)', offset, buffer, value)\n  assert(type.indirection >= 1, '\"indirection\" level must be at least 1')\n  if (type.indirection === 1) {\n    type.set(buffer, offset, value)\n  } else {\n    exports.writePointer(buffer, offset, value)\n  }\n}\n\n\n/**\n * Returns a new Buffer instance big enough to hold `type`,\n * with the given `value` written to it.\n *\n * ``` js\n * var intBuf = ref.alloc(ref.types.int)\n * var int_with_4 = ref.alloc(ref.types.int, 4)\n * ```\n *\n * @param {Object|String} type The \"type\" object to allocate. Strings get coerced first.\n * @param {?} value (optional) The initial value set on the returned Buffer, using _type_'s `set()` function.\n * @return {Buffer} A new Buffer instance with it's `type` set to \"type\", and (optionally) \"value\" written to it.\n */\n\nexports.alloc = function alloc (_type, value) {\n  var type = exports.coerceType(_type)\n  debug('allocating Buffer for type with \"size\"', type.size)\n  var size\n  if (type.indirection === 1) {\n    size = type.size\n  } else {\n    size = exports.sizeof.pointer\n  }\n  var buffer = new Buffer(size)\n  buffer.type = type\n  if (arguments.length >= 2) {\n    debug('setting value on allocated buffer', value)\n    exports.set(buffer, 0, value, type)\n  }\n  return buffer\n}\n\n/**\n * Returns a new `Buffer` instance with the given String written to it with the\n * given encoding (defaults to __'utf8'__). The buffer is 1 byte longer than the\n * string itself, and is NUL terminated.\n *\n * ```\n * var buf = ref.allocCString('hello world');\n *\n * console.log(buf.toString());\n * 'hello world\\u0000'\n * ```\n *\n * @param {String} string The JavaScript string to be converted to a C string.\n * @param {String} encoding (optional) The encoding to use for the C string. Defaults to __'utf8'__.\n * @return {Buffer} The new `Buffer` instance with the specified String wrtten to it, and a trailing NUL byte.\n */\n\nexports.allocCString = function allocCString (string, encoding) {\n  if (null == string || (Buffer.isBuffer(string) && exports.isNull(string))) {\n    return exports.NULL\n  }\n  var size = Buffer.byteLength(string, encoding) + 1\n  var buffer = new Buffer(size)\n  exports.writeCString(buffer, 0, string, encoding)\n  buffer.type = charPtrType\n  return buffer\n}\n\n/**\n * Writes the given string as a C String (NULL terminated) to the given buffer\n * at the given offset. \"encoding\" is optional and defaults to __'utf8'__.\n *\n * Unlike `readCString()`, this function requires the buffer to actually have the\n * proper length.\n *\n * @param {Buffer} buffer The Buffer instance to write to.\n * @param {Number} offset The offset of the buffer to begin writing at.\n * @param {String} string The JavaScript String to write that will be written to the buffer.\n * @param {String} encoding (optional) The encoding to read the C string as. Defaults to __'utf8'__.\n */\n\nexports.writeCString = function writeCString (buffer, offset, string, encoding) {\n  assert(Buffer.isBuffer(buffer), 'expected a Buffer as the first argument')\n  assert.equal('string', typeof string, 'expected a \"string\" as the third argument')\n  if (!offset) {\n    offset = 0\n  }\n  if (!encoding) {\n    encoding = 'utf8'\n  }\n  var size = buffer.length - offset\n  var len = buffer.write(string, offset, size, encoding)\n  buffer.writeUInt8(0, offset + len)  // NUL terminate\n}\n\nexports['readInt64' + exports.endianness] = exports.readInt64\nexports['readUInt64' + exports.endianness] = exports.readUInt64\nexports['writeInt64' + exports.endianness] = exports.writeInt64\nexports['writeUInt64' + exports.endianness] = exports.writeUInt64\n\nvar opposite = exports.endianness == 'LE' ? 'BE' : 'LE'\nvar int64temp = new Buffer(exports.sizeof.int64)\nvar uint64temp = new Buffer(exports.sizeof.uint64)\n\nexports['readInt64' + opposite] = function (buffer, offset) {\n  for (var i = 0; i < exports.sizeof.int64; i++) {\n    int64temp[i] = buffer[offset + exports.sizeof.int64 - i - 1]\n  }\n  return exports.readInt64(int64temp, 0)\n}\nexports['readUInt64' + opposite] = function (buffer, offset) {\n  for (var i = 0; i < exports.sizeof.uint64; i++) {\n    uint64temp[i] = buffer[offset + exports.sizeof.uint64 - i - 1]\n  }\n  return exports.readUInt64(uint64temp, 0)\n}\nexports['writeInt64' + opposite] = function (buffer, offset, value) {\n  exports.writeInt64(int64temp, 0, value)\n  for (var i = 0; i < exports.sizeof.int64; i++) {\n    buffer[offset + i] = int64temp[exports.sizeof.int64 - i - 1]\n  }\n}\nexports['writeUInt64' + opposite] = function (buffer, offset, value) {\n  exports.writeUInt64(uint64temp, 0, value)\n  for (var i = 0; i < exports.sizeof.uint64; i++) {\n    buffer[offset + i] = uint64temp[exports.sizeof.uint64 - i - 1]\n  }\n}\n\n/**\n * `ref()` accepts a Buffer instance and returns a new Buffer\n * instance that is \"pointer\" sized and has its data pointing to the given\n * Buffer instance. Essentially the created Buffer is a \"reference\" to the\n * original pointer, equivalent to the following C code:\n *\n * ``` c\n * char *buf = buffer;\n * char **ref = &buf;\n * ```\n *\n * @param {Buffer} buffer A Buffer instance to create a reference to.\n * @return {Buffer} A new Buffer instance pointing to _buffer_.\n */\n\nexports.ref = function ref (buffer) {\n  debug('creating a reference to buffer', buffer)\n  var type = exports.refType(exports.getType(buffer))\n  return exports.alloc(type, buffer)\n}\n\n/**\n * Accepts a Buffer instance and attempts to \"dereference\" it.\n * That is, first it checks the `indirection` count of _buffer_'s \"type\", and if\n * it's greater than __1__ then it merely returns another Buffer, but with one\n * level less `indirection`.\n *\n * When _buffer_'s indirection is at __1__, then it checks for `buffer.type`\n * which should be an Object with its own `get()` function.\n *\n * ```\n * var buf = ref.alloc('int', 6);\n *\n * var val = ref.deref(buf);\n * console.log(val);\n * 6\n * ```\n *\n *\n * @param {Buffer} buffer A Buffer instance to dereference.\n * @return {?} The returned value after dereferencing _buffer_.\n */\n\nexports.deref = function deref (buffer) {\n  debug('dereferencing buffer', buffer)\n  return exports.get(buffer)\n}\n\n/**\n * Attaches _object_ to _buffer_ such that it prevents _object_ from being garbage\n * collected until _buffer_ does.\n *\n * @param {Buffer} buffer A Buffer instance to attach _object_ to.\n * @param {Object|Buffer} object An Object or Buffer to prevent from being garbage collected until _buffer_ does.\n * @api private\n */\n\nexports._attach = function _attach (buf, obj) {\n  if (!buf._refs) {\n    buf._refs = []\n  }\n  buf._refs.push(obj)\n}\n\n/**\n * Same as `ref.writeObject()`, except that this version does not _attach_ the\n * Object to the Buffer, which is potentially unsafe if the garbage collector\n * runs.\n *\n * @param {Buffer} buffer A Buffer instance to write _object_ to.\n * @param {Number} offset The offset on the Buffer to start writing at.\n * @param {Object} object The Object to be written into _buffer_.\n * @api private\n */\n\nexports._writeObject = exports.writeObject\n\n/**\n * Writes a pointer to _object_ into _buffer_ at the specified _offset.\n *\n * This function \"attaches\" _object_ to _buffer_ to prevent it from being garbage\n * collected.\n *\n * ```\n * var buf = ref.alloc('Object');\n * ref.writeObject(buf, 0, { foo: 'bar' });\n *\n * ```\n *\n * @param {Buffer} buffer A Buffer instance to write _object_ to.\n * @param {Number} offset The offset on the Buffer to start writing at.\n * @param {Object} object The Object to be written into _buffer_.\n */\n\nexports.writeObject = function writeObject (buf, offset, obj, persistent) {\n  debug('writing Object to buffer', buf, offset, obj, persistent)\n  exports._writeObject(buf, offset, obj, persistent)\n  exports._attach(buf, obj)\n}\n\n/**\n * Same as `ref.writePointer()`, except that this version does not attach\n * _pointer_ to _buffer_, which is potentially unsafe if the garbage collector\n * runs.\n *\n * @param {Buffer} buffer A Buffer instance to write _pointer to.\n * @param {Number} offset The offset on the Buffer to start writing at.\n * @param {Buffer} pointer The Buffer instance whose memory address will be written to _buffer_.\n * @api private\n */\n\nexports._writePointer = exports.writePointer\n\n/**\n * Writes the memory address of _pointer_ to _buffer_ at the specified _offset_.\n *\n * This function \"attaches\" _object_ to _buffer_ to prevent it from being garbage\n * collected.\n *\n * ```\n * var someBuffer = new Buffer('whatever');\n * var buf = ref.alloc('pointer');\n * ref.writePointer(buf, 0, someBuffer);\n * ```\n *\n * @param {Buffer} buffer A Buffer instance to write _pointer to.\n * @param {Number} offset The offset on the Buffer to start writing at.\n * @param {Buffer} pointer The Buffer instance whose memory address will be written to _buffer_.\n */\n\nexports.writePointer = function writePointer (buf, offset, ptr) {\n  debug('writing pointer to buffer', buf, offset, ptr)\n  exports._writePointer(buf, offset, ptr)\n  exports._attach(buf, ptr)\n}\n\n/**\n * Same as `ref.reinterpret()`, except that this version does not attach\n * _buffer_ to the returned Buffer, which is potentially unsafe if the\n * garbage collector runs.\n *\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\n * @param {Number} size The `length` property of the returned Buffer.\n * @param {Number} offset The offset of the Buffer to begin from.\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and the requested _size_.\n * @api private\n */\n\nexports._reinterpret = exports.reinterpret\n\n/**\n * Returns a new Buffer instance with the specified _size_, with the same memory\n * address as _buffer_.\n *\n * This function \"attaches\" _buffer_ to the returned Buffer to prevent it from\n * being garbage collected.\n *\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\n * @param {Number} size The `length` property of the returned Buffer.\n * @param {Number} offset The offset of the Buffer to begin from.\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and the requested _size_.\n */\n\nexports.reinterpret = function reinterpret (buffer, size, offset) {\n  debug('reinterpreting buffer to \"%d\" bytes', size)\n  var rtn = exports._reinterpret(buffer, size, offset || 0)\n  exports._attach(rtn, buffer)\n  return rtn\n}\n\n/**\n * Same as `ref.reinterpretUntilZeros()`, except that this version does not\n * attach _buffer_ to the returned Buffer, which is potentially unsafe if the\n * garbage collector runs.\n *\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\n * @param {Number} size The number of sequential, aligned `NULL` bytes that are required to terminate the buffer.\n * @param {Number} offset The offset of the Buffer to begin from.\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and a variable `length` that is terminated by _size_ NUL bytes.\n * @api private\n */\n\nexports._reinterpretUntilZeros = exports.reinterpretUntilZeros\n\n/**\n * Accepts a `Buffer` instance and a number of `NULL` bytes to read from the\n * pointer. This function will scan past the boundary of the Buffer's `length`\n * until it finds `size` number of aligned `NULL` bytes.\n *\n * This is useful for finding the end of NUL-termintated array or C string. For\n * example, the `readCString()` function _could_ be implemented like:\n *\n * ```\n * function readCString (buf) {\n *   return ref.reinterpretUntilZeros(buf, 1).toString('utf8')\n * }\n * ```\n *\n * This function \"attaches\" _buffer_ to the returned Buffer to prevent it from\n * being garbage collected.\n *\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\n * @param {Number} size The number of sequential, aligned `NULL` bytes are required to terminate the buffer.\n * @param {Number} offset The offset of the Buffer to begin from.\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and a variable `length` that is terminated by _size_ NUL bytes.\n */\n\nexports.reinterpretUntilZeros = function reinterpretUntilZeros (buffer, size, offset) {\n  debug('reinterpreting buffer to until \"%d\" NULL (0) bytes are found', size)\n  var rtn = exports._reinterpretUntilZeros(buffer, size, offset || 0)\n  exports._attach(rtn, buffer)\n  return rtn\n}\n\n\n// the built-in \"types\"\nvar types = exports.types = {}\n\n/**\n * The `void` type.\n *\n * @section types\n */\n\ntypes.void = {\n    size: 0\n  , indirection: 1\n  , get: function get (buf, offset) {\n      debug('getting `void` type (returns `null`)')\n      return null\n    }\n  , set: function set (buf, offset, val) {\n      debug('setting `void` type (no-op)')\n    }\n}\n\n/**\n * The `int8` type.\n */\n\ntypes.int8 = {\n    size: exports.sizeof.int8\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf.readInt8(offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      if (typeof val === 'string') {\n        val = val.charCodeAt(0)\n      }\n      return buf.writeInt8(val, offset || 0)\n    }\n}\n\n/**\n * The `uint8` type.\n */\n\ntypes.uint8 = {\n    size: exports.sizeof.uint8\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf.readUInt8(offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      if (typeof val === 'string') {\n        val = val.charCodeAt(0)\n      }\n      return buf.writeUInt8(val, offset || 0)\n    }\n}\n\n/**\n * The `int16` type.\n */\n\ntypes.int16 = {\n    size: exports.sizeof.int16\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readInt16' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeInt16' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `uint16` type.\n */\n\ntypes.uint16 = {\n    size: exports.sizeof.uint16\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readUInt16' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeUInt16' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `int32` type.\n */\n\ntypes.int32 = {\n    size: exports.sizeof.int32\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readInt32' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeInt32' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `uint32` type.\n */\n\ntypes.uint32 = {\n    size: exports.sizeof.uint32\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readUInt32' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeUInt32' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `int64` type.\n */\n\ntypes.int64 = {\n    size: exports.sizeof.int64\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readInt64' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeInt64' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `uint64` type.\n */\n\ntypes.uint64 = {\n    size: exports.sizeof.uint64\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readUInt64' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeUInt64' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `float` type.\n */\n\ntypes.float = {\n    size: exports.sizeof.float\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readFloat' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeFloat' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `double` type.\n */\n\ntypes.double = {\n    size: exports.sizeof.double\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readDouble' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeDouble' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `Object` type. This can be used to read/write regular JS Objects\n * into raw memory.\n */\n\ntypes.Object = {\n    size: exports.sizeof.Object\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf.readObject(offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf.writeObject(val, offset || 0)\n    }\n}\n\n/**\n * The `CString` (a.k.a `\"string\"`) type.\n *\n * CStrings are a kind of weird thing. We say it's `sizeof(char *)`, and\n * `indirection` level of 1, which means that we have to return a Buffer that\n * is pointer sized, and points to a some utf8 string data, so we have to create\n * a 2nd \"in-between\" buffer.\n */\n\ntypes.CString = {\n    size: exports.sizeof.pointer\n  , alignment: exports.alignof.pointer\n  , indirection: 1\n  , get: function get (buf, offset) {\n      var _buf = exports.readPointer(buf, offset)\n      if (exports.isNull(_buf)) {\n        return null\n      }\n      return exports.readCString(_buf, 0)\n    }\n  , set: function set (buf, offset, val) {\n      var _buf\n      if (Buffer.isBuffer(val)) {\n        _buf = val\n      } else {\n        // assume string\n        _buf = exports.allocCString(val)\n      }\n      return exports.writePointer(buf, offset, _buf)\n    }\n}\n\n// alias Utf8String\nvar utfstringwarned = false\nObject.defineProperty(types, 'Utf8String', {\n    enumerable: false\n  , configurable: true\n  , get: function () {\n      if (!utfstringwarned) {\n        utfstringwarned = true\n        console.error('\"Utf8String\" type is deprecated, use \"CString\" instead')\n      }\n      return types.CString\n    }\n})\n\n/**\n * The `bool` type.\n *\n * Wrapper type around `types.uint8` that accepts/returns `true` or\n * `false` Boolean JavaScript values.\n *\n * @name bool\n *\n */\n\n/**\n * The `byte` type.\n *\n * @name byte\n */\n\n/**\n * The `char` type.\n *\n * @name char\n */\n\n/**\n * The `uchar` type.\n *\n * @name uchar\n */\n\n/**\n * The `short` type.\n *\n * @name short\n */\n\n/**\n * The `ushort` type.\n *\n * @name ushort\n */\n\n/**\n * The `int` type.\n *\n * @name int\n */\n\n/**\n * The `uint` type.\n *\n * @name uint\n */\n\n/**\n * The `long` type.\n *\n * @name long\n */\n\n/**\n * The `ulong` type.\n *\n * @name ulong\n */\n\n/**\n * The `longlong` type.\n *\n * @name longlong\n */\n\n/**\n * The `ulonglong` type.\n *\n * @name ulonglong\n */\n\n/**\n * The `size_t` type.\n *\n * @name size_t\n */\n\n// \"typedef\"s for the variable-sized types\n;[ 'bool', 'byte', 'char', 'uchar', 'short', 'ushort', 'int', 'uint', 'long'\n, 'ulong', 'longlong', 'ulonglong', 'size_t' ].forEach(function (name) {\n  var unsigned = name === 'bool'\n              || name === 'byte'\n              || name === 'size_t'\n              || name[0] === 'u'\n  var size = exports.sizeof[name]\n  assert(size >= 1 && size <= 8)\n  var typeName = 'int' + (size * 8)\n  if (unsigned) {\n    typeName = 'u' + typeName\n  }\n  var type = exports.types[typeName]\n  assert(type)\n  exports.types[name] = Object.create(type)\n})\n\n// set the \"alignment\" property on the built-in types\nObject.keys(exports.alignof).forEach(function (name) {\n  if (name === 'pointer') return\n  exports.types[name].alignment = exports.alignof[name]\n  assert(exports.types[name].alignment > 0)\n})\n\n// make the `bool` type work with JS true/false values\nexports.types.bool.get = (function (_get) {\n  return function get (buf, offset) {\n    return _get(buf, offset) ? true : false\n  }\n})(exports.types.bool.get)\nexports.types.bool.set = (function (_set) {\n  return function set (buf, offset, val) {\n    if (typeof val !== 'number') {\n      val = val ? 1 : 0\n    }\n    return _set(buf, offset, val)\n  }\n})(exports.types.bool.set)\n\n/*!\n * Set the `name` property of the types. Used for debugging...\n */\n\nObject.keys(exports.types).forEach(function (name) {\n  exports.types[name].name = name\n})\n\n/*!\n * This `char *` type is used by \"allocCString()\" above.\n */\n\nvar charPtrType = exports.refType(exports.types.char)\n\n/*!\n * Set the `type` property of the `NULL` pointer Buffer object.\n */\n\nexports.NULL.type = exports.types.void\n\n/**\n * `NULL_POINTER` is a pointer-sized `Buffer` instance pointing to `NULL`.\n * Conceptually, it's equivalent to the following C code:\n *\n * ``` c\n * char *null_pointer;\n * null_pointer = NULL;\n * ```\n *\n * @type Buffer\n */\n\nexports.NULL_POINTER = exports.ref(exports.NULL)\n\n/**\n * All these '...' comment blocks below are for the documentation generator.\n *\n * @section buffer\n */\n\nBuffer.prototype.address = function address () {\n  return exports.address(this, 0)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.hexAddress = function hexAddress () {\n  return exports.hexAddress(this, 0)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.isNull = function isNull () {\n  return exports.isNull(this, 0)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.ref = function ref () {\n  return exports.ref(this)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.deref = function deref () {\n  return exports.deref(this)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readObject = function readObject (offset) {\n  return exports.readObject(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeObject = function writeObject (obj, offset) {\n  return exports.writeObject(this, offset, obj)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readPointer = function readPointer (offset, size) {\n  return exports.readPointer(this, offset, size)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writePointer = function writePointer (ptr, offset) {\n  return exports.writePointer(this, offset, ptr)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readCString = function readCString (offset) {\n  return exports.readCString(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeCString = function writeCString (string, offset, encoding) {\n  return exports.writeCString(this, offset, string, encoding)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readInt64BE = function readInt64BE (offset) {\n  return exports.readInt64BE(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeInt64BE = function writeInt64BE (val, offset) {\n  return exports.writeInt64BE(this, offset, val)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readUInt64BE = function readUInt64BE (offset) {\n  return exports.readUInt64BE(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeUInt64BE = function writeUInt64BE (val, offset) {\n  return exports.writeUInt64BE(this, offset, val)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readInt64LE = function readInt64LE (offset) {\n  return exports.readInt64LE(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeInt64LE = function writeInt64LE (val, offset) {\n  return exports.writeInt64LE(this, offset, val)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readUInt64LE = function readUInt64LE (offset) {\n  return exports.readUInt64LE(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeUInt64LE = function writeUInt64LE (val, offset) {\n  return exports.writeUInt64LE(this, offset, val)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.reinterpret = function reinterpret (size, offset) {\n  return exports.reinterpret(this, size, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.reinterpretUntilZeros = function reinterpretUntilZeros (size, offset) {\n  return exports.reinterpretUntilZeros(this, size, offset)\n}\n\n/**\n * `ref` overwrites the default `Buffer#inspect()` function to include the\n * hex-encoded memory address of the Buffer instance when invoked.\n *\n * This is simply a nice-to-have.\n *\n * **Before**:\n *\n * ``` js\n * console.log(new Buffer('ref'));\n * <Buffer 72 65 66>\n * ```\n *\n * **After**:\n *\n * ``` js\n * console.log(new Buffer('ref'));\n * <Buffer@0x103015490 72 65 66>\n * ```\n */\n\nBuffer.prototype.inspect = overwriteInspect(Buffer.prototype.inspect)\n\n// does SlowBuffer inherit from Buffer? (node >= v0.7.9)\nif (!(exports.NULL instanceof Buffer)) {\n  debug('extending SlowBuffer\\'s prototype since it doesn\\'t inherit from Buffer.prototype')\n\n  /*!\n   * SlowBuffer convenience methods.\n   */\n\n  var SlowBuffer = require('buffer').SlowBuffer\n\n  SlowBuffer.prototype.address = Buffer.prototype.address\n  SlowBuffer.prototype.hexAddress = Buffer.prototype.hexAddress\n  SlowBuffer.prototype.isNull = Buffer.prototype.isNull\n  SlowBuffer.prototype.ref = Buffer.prototype.ref\n  SlowBuffer.prototype.deref = Buffer.prototype.deref\n  SlowBuffer.prototype.readObject = Buffer.prototype.readObject\n  SlowBuffer.prototype.writeObject = Buffer.prototype.writeObject\n  SlowBuffer.prototype.readPointer = Buffer.prototype.readPointer\n  SlowBuffer.prototype.writePointer = Buffer.prototype.writePointer\n  SlowBuffer.prototype.readCString = Buffer.prototype.readCString\n  SlowBuffer.prototype.writeCString = Buffer.prototype.writeCString\n  SlowBuffer.prototype.reinterpret = Buffer.prototype.reinterpret\n  SlowBuffer.prototype.reinterpretUntilZeros = Buffer.prototype.reinterpretUntilZeros\n  SlowBuffer.prototype.readInt64BE = Buffer.prototype.readInt64BE\n  SlowBuffer.prototype.writeInt64BE = Buffer.prototype.writeInt64BE\n  SlowBuffer.prototype.readUInt64BE = Buffer.prototype.readUInt64BE\n  SlowBuffer.prototype.writeUInt64BE = Buffer.prototype.writeUInt64BE\n  SlowBuffer.prototype.readInt64LE = Buffer.prototype.readInt64LE\n  SlowBuffer.prototype.writeInt64LE = Buffer.prototype.writeInt64LE\n  SlowBuffer.prototype.readUInt64LE = Buffer.prototype.readUInt64LE\n  SlowBuffer.prototype.writeUInt64LE = Buffer.prototype.writeUInt64LE\n  SlowBuffer.prototype.inspect = overwriteInspect(SlowBuffer.prototype.inspect)\n}\n\nfunction overwriteInspect (inspect) {\n  if (inspect.name === 'refinspect') {\n    return inspect\n  } else {\n    return function refinspect () {\n      var v = inspect.apply(this, arguments)\n      return v.replace('Buffer', 'Buffer@0x' + this.hexAddress())\n    }\n  }\n}\n"}